#version 450

#extension GL_ARB_separate_shader_objects : enable
#extension GL_ARB_shading_language_420pack : enable

layout (local_size_x = 16, local_size_y = 16) in;
layout (rgba8, binding = 0) uniform writeonly image2D outputImage;
layout (binding = 1) uniform sampler2DArray samplerColor;
layout (binding = 2) uniform sampler2DArray samplerOffsets;
layout (binding = 3) uniform sampler2D bloomSampler;
layout (binding = 4) uniform sampler2DArray overlaySampler;

layout(push_constant) uniform PushConstants {
	int arrayBufferFrame;
	int validFrames;
	int delayImage;
	int overlayIndex;
	float delayAmount;
	float delayChroma;
	float overlayAlpha;
	float fade;
	float flash;
} pushConstants;

vec3 spectrum_offset(float t)
{
	// Thanks to mentor! https://twitter.com/Stubbesaurus/status/818847844790575104
	float t0 = 3.0 * t - 1.5;
	return clamp( vec3( -t0, 1.0-abs(t0), t0), 0.0, 1.0);
}

float nrand(vec2 n)
{
	return fract(sin(dot(n.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

vec3 sampleSpectrum(float timeA, float timeB)
{
	// thanks to Hornet ;)
	const int num_iter = 7;
	const float stepsiz = 1.0 / (num_iter - 1);

	float rnd = nrand(gl_GlobalInvocationID.xy + pushConstants.arrayBufferFrame * 0.1);
	float t = rnd * stepsiz;

	int slices = textureSize(samplerColor, 0).z;

	vec3 sumcol = vec3(0.0);
	vec3 sumw = vec3(0.0);
	for (int i = 0; i < num_iter; ++i)
	{
		vec3 w = spectrum_offset(t);
		sumw += w;

		float time = mix(timeA, timeB, t);
		int slice = int(time);

		vec3 a = texelFetch(samplerColor, ivec3(ivec2(gl_GlobalInvocationID.xy), (slice + 0) % slices), 0).xyz;
		vec3 b = texelFetch(samplerColor, ivec3(ivec2(gl_GlobalInvocationID.xy), (slice + 1) % slices), 0).xyz;
		vec3 color = mix(a, b, fract(time));

		sumcol += w * color;
		t += stepsiz;
	}
	return sumcol.rgb /= sumw;
}

vec3 sampleBloom(vec2 pos)
{
	vec3 sum = vec3(0);
	int levels = textureQueryLevels(bloomSampler);
	float total = 0;
	for (int i = 0; i < levels; ++i) {
		float weight = pow(float(i), 0.5);
		vec2 rnd = vec2(nrand(3 + gl_GlobalInvocationID.xy + pushConstants.arrayBufferFrame * 0.01),
		                nrand(5 + gl_GlobalInvocationID.yx - pushConstants.arrayBufferFrame * 0.01));
		rnd = (rnd * 2 - 1) / textureSize(bloomSampler, i);
		sum += textureLod(bloomSampler, pos + rnd * 0.25, float(i)).rgb * weight;
		total += weight;
	}
	return sum / total;
}

void main()
{
	vec2 pos = (gl_GlobalInvocationID.xy + 0.5) / imageSize(outputImage);

	float time = pushConstants.arrayBufferFrame;
	float delay = textureLod(samplerOffsets, vec3(pos.xy, pushConstants.delayImage), 0).x;
	delay *= pushConstants.delayAmount;
	delay *= textureSize(samplerColor, 0).z;
	delay = clamp(delay, 0, pushConstants.validFrames - 1);

	vec3 color = sampleSpectrum(time - delay, time - delay * pushConstants.delayChroma);

	vec4 overlay = textureLod(overlaySampler, vec3(pos.xy, pushConstants.overlayIndex), 0);
	color = color * (1 - overlay.a * pushConstants.overlayAlpha) + overlay.rgb * pushConstants.overlayAlpha;

	// vignette
	color *= 1.0 - distance(pos, vec2(0.5));

	color = color * pushConstants.fade + pushConstants.flash;

	imageStore(outputImage, ivec2(gl_GlobalInvocationID.xy), vec4(color, 1));
}
